# ES2015

## Babel转码

函数拓展

let const数据结构

map数据结构

set数据结构

## 严格模式

### 作用

1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为；
2. 消除代码运行的一些不安全之处，保证代码运行的安全；
3. 提高编译器效率，增加运行速度；
4. 为未来新版本的Javascript做好铺垫；

### 进入严格模式

1. "use strict";
   1. 将"use strict"放在脚本文件的第一行，则整个脚本都将以"严格模式"运行；
   2. 将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行；

2. 使用Class时自动转换为全局严格模式；

### 要求

1. 不允许使用未声明的变量；（对象也是一个变量）
2. 不允许删除变量或对象；
3. 不允许删除函数；
4. 不允许变量重名；
5. 不允许使用八进制；
6. 不允许使用转义字符；
7. 不允许对只读属性赋值；
8. 不允许对一个使用getter方法读取的属性进行赋值；
9. 不允许删除一个不允许删除的属性；
10. 禁止使用with语句；
11. 变量名不能使用 "eval" 字符串；
12. 变量名不能使用 "arguments" 字符串；
13. 由于一些安全原因，在作用域 eval() 创建的变量不能被调用；
14. 禁止this关键字指向全局对象；
15. 使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错；
16. 新增了一些保留字；

## 解构赋值

> 只要等号两边的模式相同，左边的变量就会被赋予对应的值

> 如果解构不成功，变量的值就等于`undefined`

## 变量

### let

1. 隶属于块级作用域，块级作用域外不可见；
2. 不存在“变量提升”与死区；
3. 同一作用域内不得存在名称相同的变量；
4. 当声明为全局变量时不会作为全局对象的属性；
5. 不允许重复声明；

### const

1. 声明常量；（块级作用域，在一个作用域里只能有一个且不可重新声明）
2. 在声明时必须赋值；
3. 不能改变值，否则会报错；
4. 不同作用域声明的常量互不影响；
5. 可以定义成对象，且同样不可重写；但对象的属性不受影响；
6. 可以用来定义数组，切可以向数组内填充数据，但是，将一个新数组赋给变量会引发错误

### 块级作用域

1. 内层变量不会覆盖外层变量；
2. 用来计数的循环变量不会泄露为全局变量；
3. ES6 允许块级作用域的任意嵌套，且外层作用域无法读取内层作用域的变量；
4. 内层作用域可以定义外层作用域的同名变量

#### 块级作用域与函数声明

1. ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。（但是浏览器为了兼容旧代码，依然支持）
2. ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

## 字符串的扩展

### 新扩展的方法

##### `startsWith()`

> 返回值

返回布尔值，表示参数字符串是否在原字符串的头部；

##### `endsWith()`

> 返回值

返回布尔值，表示参数字符串是否在原字符串的尾部；

### 字符串模版

> 语法

```js
${变量名}
```

> Example

```js
const a = 'yy';
console.log(`my name is ${a}`);
```

### 函数的扩展

#### 箭头函数

1. 如果只有一个参数，`()` 可以省略；
2. 如果只有一条return,`{}` 可以省略；

> 语法

```js
var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
```


### class

1. 可以看作构造函数的另一种写法；
2. 构造函数的`prototype`属性，在 ES6 的“类”上面继续存在；

# ES2016

指数操作符