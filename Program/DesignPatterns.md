  

# 设计模式 

**一种可以复用的解决方案**

> 一个好的设计模式可以执行以下操作

- 解决特殊问题
- 没有显而易见的解决方案
- 描述业经验证的概念
- 描述一种关系

> 三法则

- 合适性
- 实用性
- 适用性

> 设计模式的结构

- 模式名称
- 描述
- 上下文大纲
- 问题陈述
- 解决方案
- 设计
- 实现
- 插图
- 示例
- 辅助条件
- 关系
- 已知的用法
- 讨论

> 反模式 `1955年由安德鲁·凯尼格在当年的11月C++报告中创造的，是受‘四人组’所著《设计模式》一书的启发`

- 描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生

- 描述如何摆脱前述的糟糕情况以及如何创造好的解决方案

## 设计模式类别

### 创建型设计模式

> 创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象

#### Constructor（构造器）

#### Factory（工厂）

#### Abstract（抽象）

#### Prototype（原型）

#### Singleton（单例）

#### Builder（生成器）

### 结构型设计模式

> 结构型设计模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法

#### Decorator（装饰者）

#### Facade（外观）

#### Flyweight（单元）

#### Adapter（适配器）

#### Proxy（代理）

### 行为设计模式

> 行为模式专注于改善或简化系统中不同对象之间的通信

#### Iterator（迭代器）

#### Mediator（中介者）

#### Observer（观察者）

#### Visitor（访问者）

## 设计模式分类

<table style="border: 3px solid #000">
  <tr>
    <td style="font-weight: bold;">创建型模式</td>
    <td style="font-weight: bold;">基于创建对象的概念</td>
  </tr>
  <tr>
    <td colspan='2' style="border-top: 2px solid #000">类</td>
  </tr>
  <tr>
    <td>工厂方法</td>
    <td>基于接口数据或事件生成几个派生类的实例</td>
  </tr>
  <tr>
    <td colspan="2">对象</td>
  </tr>
  <tr>
    <td>抽象工厂</td>
    <td>创建若干类系列的一个实例，无需详述具体的类</td>
  </tr>
  <tr>
    <td>生成器</td>
    <td>从表示中分离对象构建；总是创建相同的类型的对象</td>
  </tr>
  <tr>
    <td>原型</td>
    <td>用于复制或克隆完全初始化的实例</td>
  </tr>
  <tr>
    <td>单例</td>
    <td>一个类在全局访问点只有唯一一个实例</td>
  </tr>
  <tr>
    <td>结构型模式</td>
    <td>基于构建对象块的想法</td>
  </tr>
  <tr>
    <td colspan="2" style="border-top: 2px solid #000">类</td>
  </tr>
  <tr>
    <td>适配器</td>
    <td>匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作</td>
  </tr>
  <tr>
    <td colspan="2">对象</td>
  </tr>
  <tr>
    <td>适配器</td>
    <td>匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作</td>
  </tr>
  <tr>
    <td>桥接</td>
    <td>将对象接口从其实现中分离，因此它们可以独立进行变化</td>
  </tr>
  <tr>
    <td>组合</td>
    <td>简单和复合对象的结构，使对象的总和不只是它各种部分的总和</td>
  </tr>
  <tr>
    <td>装饰</td>
    <td>向对象动态添加备选的处理</td>
  </tr>
  <tr>
    <td>外观</td>
    <td>隐藏整个子系统复杂性的唯一一个类</td>
  </tr>
  <tr>
    <td>享元</td>
    <td>一个用于实现包含在别处信息的高效共享的细粒度实例</td>
  </tr>
  <tr>
    <td>代理</td>
    <td>占位符对象代表真正的对象</td>
  </tr>
  <tr>
    <td>行为模式</td>
    <td>基于对象在一起配合工作的方式</td>
  </tr>
  <tr>
    <td colspan="2" style="border-top: 2px solid #000">类</td>
  </tr>
  <tr>
    <td>解释器</td>
    <td>将语言元素包含在应用程序中的方法，以匹配预期语言的语法</td>
  </tr>
  <tr>
    <td>模版方法</td>
    <td>在方法中创建算法的shell，然后将确切的步骤推到子类</td>
  </tr>
  <tr>
    <td colspan="2" style="border-top: 2px solid #000">对象</td>
  </tr>
  <tr>
    <td>职责链</td>
    <td>在对象链之间传递请求的方法，以找到能够处理请求的对象</td>
  </tr>
  <tr>
    <td>命令</td>
    <td>将命令执行从其调用程序中分离的方法</td>
  </tr>
  <tr>
    <td>迭代器</td>
    <td>顺序访问一个集合中的元素，无需了解该集合的内部工作原理</td>
  </tr>
  <tr>
    <td>中介者</td>
    <td>在类之间定义简化的通信，以防止一组类显示引用彼此</td>
  </tr>
  <tr>
    <td>备忘录</td>
    <td>捕获对象的内部状态，以能够在以后恢复它</td>
  </tr>
  <tr>
    <td>观察者</td>
    <td>向多个类通知改变的方式，以确保类之间的一致性</td>
  </tr>
  <tr>
    <td>状态</td>
    <td>状态改变时，更改对象的行为</td>
  </tr>
  <tr>
    <td>策略</td>
    <td>在一个类中封装算法，将选择与实现分离</td>
  </tr>
  <tr>
    <td>访问者</td>
    <td>向类添加一个新的操作，无需改变类</td>
  </tr>
</table>

